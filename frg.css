import google.auth
import google.auth.transport.requests
from google.cloud.sql.connector import Connector
import time
import psycopg2

def get_cf_default_access_token():
    print("Start: generating access token")
    try:
        creds, project = google.auth.default()
        auth_req = creds.refresh(google.auth.transport.requests.Request())
    except Exception as e:
        print("Error: generating access token")
        print(e)
        return None
    print("End: generating access token")
    return creds.token

def get_db_connection(connection_str, user, password):
    print(f'Start: getting db connection for {user}')
    conn = None
    for i in range(5):
        try:
            connector = Connector()
            conn = connector.connect(
                connection_str,
                "pg8000",
                ip_type="psc",
                user=user,
                password=password,
                db="psc_test"
            )
            break
        except Exception as e:
            print(f'Error: getting db connection for {user}')
            print(e)
            time.sleep(5)
    print(f'End: getting db connection for {user}')
    return conn

class DatabaseOperations:
    def __init__(self, connection):
        self.conn = connection
        self.cursor = connection.cursor()

    def create_record(self, table_name, data):
        """
        Create a new record in the specified table
        :param table_name: Name of the table
        :param data: Dictionary containing column names and values
        :return: ID of the created record
        """
        columns = ', '.join(data.keys())
        values = ', '.join(['%s'] * len(data))
        query = f"INSERT INTO {table_name} ({columns}) VALUES ({values}) RETURNING id"
        
        try:
            self.cursor.execute(query, list(data.values()))
            self.conn.commit()
            return self.cursor.fetchone()[0]
        except Exception as e:
            self.conn.rollback()
            print(f"Error creating record: {e}")
            raise

    def read_records(self, table_name, conditions=None, fields=None):
        """
        Read records from the specified table
        :param table_name: Name of the table
        :param conditions: Dictionary of WHERE conditions
        :param fields: List of fields to retrieve (None for all fields)
        :return: List of records
        """
        fields_str = '*' if not fields else ', '.join(fields)
        query = f"SELECT {fields_str} FROM {table_name}"
        
        if conditions:
            where_clauses = [f"{k} = %s" for k in conditions.keys()]
            query += " WHERE " + " AND ".join(where_clauses)
            
        try:
            self.cursor.execute(query, list(conditions.values()) if conditions else None)
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error reading records: {e}")
            raise

    def update_record(self, table_name, data, conditions):
        """
        Update records in the specified table
        :param table_name: Name of the table
        :param data: Dictionary containing column names and new values
        :param conditions: Dictionary of WHERE conditions
        :return: Number of updated records
        """
        set_clause = ', '.join([f"{k} = %s" for k in data.keys()])
        where_clause = ' AND '.join([f"{k} = %s" for k in conditions.keys()])
        query = f"UPDATE {table_name} SET {set_clause} WHERE {where_clause}"
        
        try:
            self.cursor.execute(query, list(data.values()) + list(conditions.values()))
            self.conn.commit()
            return self.cursor.rowcount
        except Exception as e:
            self.conn.rollback()
            print(f"Error updating record: {e}")
            raise

    def delete_record(self, table_name, conditions):
        """
        Delete records from the specified table
        :param table_name: Name of the table
        :param conditions: Dictionary of WHERE conditions
        :return: Number of deleted records
        """
        where_clause = ' AND '.join([f"{k} = %s" for k in conditions.keys()])
        query = f"DELETE FROM {table_name} WHERE {where_clause}"
        
        try:
            self.cursor.execute(query, list(conditions.values()))
            self.conn.commit()
            return self.cursor.rowcount
        except Exception as e:
            self.conn.rollback()
            print(f"Error deleting record: {e}")
            raise

    def close(self):
        """
        Close the database connection and cursor
        """
        self.cursor.close()
        self.conn.close()

# Example usage:
if __name__ == "__main__":
    # Your existing connection setup
    password = get_cf_default_access_token()
    connection_str = "prj-d-netsec:us-central1:cloudsql-with-psc"
    user = "svc-d-lumi-poc-sa@prj-d-lumi-poc.iam"
    
    # Get connection
    conn = get_db_connection(connection_str, user, password)
    
    try:
        # Initialize database operations
        db_ops = DatabaseOperations(conn)
        
        # Example CRUD operations
        # Create
        new_record = {
            "name": "Test User",
            "email": "test@example.com",
            "created_at": "2024-03-21"
        }
        new_id = db_ops.create_record("users", new_record)
        print(f"Created record with ID: {new_id}")
        
        # Read
        records = db_ops.read_records("users", {"id": new_id})
        print(f"Retrieved records: {records}")
        
        # Update
        updated_data = {"name": "Updated User"}
        updated_count = db_ops.update_record("users", updated_data, {"id": new_id})
        print(f"Updated {updated_count} records")
        
        # Delete
        deleted_count = db_ops.delete_record("users", {"id": new_id})
        print(f"Deleted {deleted_count} records")
        
    finally:
        # Close the connection
        db_ops.close()