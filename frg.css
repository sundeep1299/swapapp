 I see the issue. The pagination numbers are extending beyond the visible area of the web view. To fix this, we can implement a more compact pagination system that shows only a limited number of page numbers and includes "Previous" and "Next" buttons. Here's an updated version of the Pagination component:

```jsx
const Pagination = ({ itemsPerPage, totalItems, paginate, currentPage }) => {
  const pageNumbers = [];
  for (let i = 1; i <= Math.ceil(totalItems / itemsPerPage); i++) {
    pageNumbers.push(i);
  }

  const maxPageNumbersToShow = 5; // Adjust this number as needed
  let startPage, endPage;

  if (pageNumbers.length <= maxPageNumbersToShow) {
    startPage = 1;
    endPage = pageNumbers.length;
  } else {
    const maxPagesBeforeCurrentPage = Math.floor(maxPageNumbersToShow / 2);
    const maxPagesAfterCurrentPage = Math.ceil(maxPageNumbersToShow / 2) - 1;

    if (currentPage <= maxPagesBeforeCurrentPage) {
      startPage = 1;
      endPage = maxPageNumbersToShow;
    } else if (currentPage + maxPagesAfterCurrentPage >= pageNumbers.length) {
      startPage = pageNumbers.length - maxPageNumbersToShow + 1;
      endPage = pageNumbers.length;
    } else {
      startPage = currentPage - maxPagesBeforeCurrentPage;
      endPage = currentPage + maxPagesAfterCurrentPage;
    }
  }

  const handlePrevious = () => {
    if (currentPage > 1) paginate(currentPage - 1);
  };

  const handleNext = () => {
    if (currentPage < pageNumbers.length) paginate(currentPage + 1);
  };

  return (
    <nav>
      <ul className="pagination">
        <li className={`page-item ${currentPage === 1 ? 'disabled' : ''}`}>
          <button onClick={handlePrevious} className="page-link">Previous</button>
        </li>
        {startPage > 1 && (
          <>
            <li className="page-item"><button onClick={() => paginate(1)} className="page-link">1</button></li>
            {startPage > 2 && <li className="page-ellipsis">...</li>}
          </>
        )}
        {pageNumbers.slice(startPage - 1, endPage).map(number => (
          <li key={number} className={`page-item ${currentPage === number ? 'active' : ''}`}>
            <button onClick={() => paginate(number)} className="page-link">
              {number}
            </button>
          </li>
        ))}
        {endPage < pageNumbers.length && (
          <>
            {endPage < pageNumbers.length - 1 && <li className="page-ellipsis">...</li>}
            <li className="page-item"><button onClick={() => paginate(pageNumbers.length)} className="page-link">{pageNumbers.length}</button></li>
          </>
        )}
        <li className={`page-item ${currentPage === pageNumbers.length ? 'disabled' : ''}`}>
          <button onClick={handleNext} className="page-link">Next</button>
        </li>
      </ul>
    </nav>
  );
};
```

Then, update your CSS to accommodate these changes:

```css
.pagination {
  display: flex;
  list-style: none;
  padding: 0;
  justify-content: center;
  margin-top: 20px;
  flex-wrap: wrap;
}

.page-item {
  margin: 2px;
}

.page-link {
  padding: 5px 10px;
  border: 1px solid #ddd;
  background-color: #f8f9fa;
  color: #007bff;
  cursor: pointer;
}

.page-item.active .page-link {
  background-color: #007bff;
  color: white;
}

.page-item.disabled .page-link {
  color: #6c757d;
  pointer-events: none;
  cursor: not-allowed;
}

.page-ellipsis {
  padding: 5px;
}
```

This updated pagination system will:

1. Show a limited number of page numbers (adjustable via `maxPageNumbersToShow`).
2. Always show the first and last page numbers.
3. Use ellipsis (...) to indicate skipped page numbers.
4. Include "Previous" and "Next" buttons for easier navigation.
5. Disable "Previous" on the first page and "Next" on the last page.
6. Use flex-wrap to ensure the pagination fits within the container.

These changes should make the pagination more compact and responsive, preventing it from overflowing the web view. Adjust the `maxPageNumbersToShow` value as needed to fit your design.