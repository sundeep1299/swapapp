 Certainly! Here's the complete code for the Services component with pagination and all the implementations we've discussed:

```jsx
import React, { useState, useEffect } from 'react';
import { FilterMenu, Checkbox, RadioGroup, RadioButton, ButtonPrimary } from '@americanexpress/dls-react';
import './Services.css';

const ITEMS_PER_PAGE = 10;

const Services = () => {
  const [services, setServices] = useState([]);
  const [filteredServices, setFilteredServices] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showMenu, setShowMenu] = useState(false);
  const [filters, setFilters] = useState({
    type: [],
    status: ''
  });
  const [currentPage, setCurrentPage] = useState(1);

  useEffect(() => {
    fetchServices();
  }, []);

  useEffect(() => {
    applyFilters();
  }, [services, filters]);

  const fetchServices = async () => {
    try {
      const response = await fetch('https://lumigcpauto-dev.aexp.com/admin/resources', {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setServices(data);
      setFilteredServices(data);
    } catch (e) {
      console.error('Error fetching services:', e);
      setError('Failed to fetch services. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const applyFilters = () => {
    let result = services;

    if (filters.type.length > 0) {
      result = result.filter(service => filters.type.includes(service.type));
    }

    if (filters.status) {
      result = result.filter(service => service.status === filters.status);
    }

    setFilteredServices(result);
    setCurrentPage(1);  // Reset to first page when filters change
  };

  const handleFilterClick = () => {
    setShowMenu(!showMenu);
  };

  const handleClose = () => {
    setShowMenu(false);
  };

  const handleApply = () => {
    applyFilters();
    setShowMenu(false);
  };

  const handleTypeChange = (event) => {
    const { value, checked } = event.target;
    setFilters(prevFilters => ({
      ...prevFilters,
      type: checked 
        ? [...prevFilters.type, value]
        : prevFilters.type.filter(type => type !== value)
    }));
  };

  const handleStatusChange = (event) => {
    setFilters(prevFilters => ({
      ...prevFilters,
      status: event.target.value
    }));
  };

  const parseConfig = (configString) => {
    const configObj = {};
    const pairs = configString.match(/(\w+)\s*=\s*"([^"]+)"/g);
    if (pairs) {
      pairs.forEach(pair => {
        const [key, value] = pair.split('=').map(item => item.trim().replace(/"/g, ''));
        configObj[key] = value;
      });
    }
    return configObj;
  };

  // Pagination
  const indexOfLastItem = currentPage * ITEMS_PER_PAGE;
  const indexOfFirstItem = indexOfLastItem - ITEMS_PER_PAGE;
  const currentItems = filteredServices.slice(indexOfFirstItem, indexOfLastItem);

  const paginate = (pageNumber) => setCurrentPage(pageNumber);

  return (
    <div className="services-container">
      <h1>All Services</h1>
      <FilterMenu
        showMenu={showMenu}
        showResetButton={false}
        onFilterButtonClick={handleFilterClick}
        onClose={handleClose}
        onApplyButtonClick={handleApply}
        filtersApplied={filters.type.length > 0 || filters.status !== ''}
        filtersLabel="Filter by category"
      >
        <RadioGroup defaultChecked="1">
          <legend theme={{
            padding: '20px 18px',
            lineHeight: '18px',
            fontWeight: '18px important'
          }}>
            STATUS
          </legend>
          <RadioButton 
            id="active-radio" 
            label="Active" 
            value="ACTIVE"
            checked={filters.status === 'ACTIVE'}
            onChange={handleStatusChange}
          />
          <RadioButton 
            id="terminated-radio" 
            label="Terminated" 
            value="TERMINATED"
            checked={filters.status === 'TERMINATED'}
            onChange={handleStatusChange}
          />
        </RadioGroup>
        <h3 className="heading-1 pad-1r pad-t-1r margin-b-0">TYPE</h3>
        <div role="group" className="pad-1" aria-labelledby="animals-label">
          <Checkbox 
            id="multi-filter-check-1" 
            label="Workbench Instance" 
            value="workbench_instance"
            checked={filters.type.includes('workbench_instance')}
            onChange={handleTypeChange}
          />
          <Checkbox 
            id="multi-filter-check-2" 
            label="Data Proc" 
            value="data_proc"
            checked={filters.type.includes('data_proc')}
            onChange={handleTypeChange}
          />
        </div>
      </FilterMenu>

      {loading && <p>Loading services...</p>}
      {error && <p className="error-message">{error}</p>}
      {currentItems.length > 0 && (
        <>
          <table className="services-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Type</th>
                <th>Created By</th>
                <th>Status</th>
                <th>Created At</th>
                <th>Updated At</th>
                <th>Project ID</th>
                <th>Region</th>
                <th>Zone</th>
              </tr>
            </thead>
            <tbody>
              {currentItems.map((service) => {
                const config = parseConfig(service.config || '');
                return (
                  <tr key={service.id}>
                    <td>{service.id || 'N/A'}</td>
                    <td>{service.name || 'N/A'}</td>
                    <td>{service.type || 'N/A'}</td>
                    <td>{service.createdBy || 'N/A'}</td>
                    <td>{service.status || 'N/A'}</td>
                    <td>{service.createdAt ? new Date(service.createdAt).toLocaleString() : 'N/A'}</td>
                    <td>{service.updatedAt ? new Date(service.updatedAt).toLocaleString() : 'N/A'}</td>
                    <td>{config.project_id || 'N/A'}</td>
                    <td>{config.region || 'N/A'}</td>
                    <td>{config.zone || 'N/A'}</td>
                  </tr>
                );
              })}
            </tbody>
          </table>
          <Pagination
            itemsPerPage={ITEMS_PER_PAGE}
            totalItems={filteredServices.length}
            paginate={paginate}
            currentPage={currentPage}
          />
        </>
      )}
    </div>
  );
};

const Pagination = ({ itemsPerPage, totalItems, paginate, currentPage }) => {
  const pageNumbers = [];

  for (let i = 1; i <= Math.ceil(totalItems / itemsPerPage); i++) {
    pageNumbers.push(i);
  }

  return (
    <nav>
      <ul className='pagination'>
        {pageNumbers.map(number => (
          <li key={number} className={`page-item ${currentPage === number ? 'active' : ''}`}>
            <ButtonPrimary onClick={() => paginate(number)} className='page-link'>
              {number}
            </ButtonPrimary>
          </li>
        ))}
      </ul>
    </nav>
  );
};

export default Services;
```

And here's the CSS for this component (Services.css):

```css
.services-container {
  padding: 20px;
  max-width: 1200px;
  margin: 0 auto;
}

.services-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
}

.services-table th,
.services-table td {
  border: 1px solid #ddd;
  padding: 8px;
  text-align: left;
}

.services-table th {
  background-color: #f2f2f2;
  font-weight: bold;
}

.error-message {
  color: red;
  font-weight: bold;
}

.pagination {
  display: flex;
  list-style: none;
  padding: 0;
  justify-content: center;
  margin-top: 20px;
}

.page-item {
  margin: 0 5px;
}

.page-link {
  padding: 5px 10px;
  border: 1px solid #ddd;
  color: #007bff;
  cursor: pointer;
}

.page-item.active .page-link {
  background-color: #007bff;
  color: white;
}

.filter-section {
  margin-bottom: 20px;
}

.filter-section h3 {
  margin-bottom: 10px;
}
```

This complete implementation includes:

1. Fetching services from the API
2. Filtering functionality (by type and status)
3. Pagination
4. Error handling
5. Loading state
6. A table to display the services
7. Styling for all components

Make sure to adjust the API endpoint, filter options, and styling as needed to fit your specific requirements.