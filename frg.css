Here's the complete implementation for both files:

1. First, let's update `app.py`:

```python
from flask import Flask, request, jsonify
from flask_cors import CORS
from request_to_llm import main
import asyncio

app = Flask(__name__)
CORS(app)

@app.route('/query', methods=['POST'])
async def lumi_orchestrator():
    try:
        data = request.get_json()
        if "query" not in data:
            return jsonify({"error": "query is required"}), 400
            
        query = data.get('query')
        print(query)
        # Await the async main function
        result = await main(query)
        print("result is", result)
        return jsonify(result)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    # Use asyncio to run the Flask app
    app.run(debug=True)
```

2. Keep your `request_to_llm.py` as is, since it's already properly structured with async functions:

```python
# request_to_llm.py remains the same as your current implementation
# Just ensure it's using the correct database configuration

async def main(query: str):
    print("Inside main")
    # Database configuration
    db_config = {
        "database": "lumitoolsdb",
        "user": "lumitoolsdb_app",
        "password": "lumitoolsdb_appw1u1",
        "host": "10.11.144.230",
        "port": "5432"
    }

    # Initialize RAG system
    rag = SimpleRAG(db_config)
    result = await rag.process_query(query)
    return {"results": result}
```

3. To run and test:

```bash
# Terminal 1 - Start the server
python app.py

# Terminal 2 - Test with curl
curl -X POST http://127.0.0.1:5000/query \
-H "Content-Type: application/json" \
-d '{"query": "What is Lumi"}'
```

4. For a more complete test script, you can create `test_api.py`:

```python
import requests
import json

def test_api():
    url = "http://127.0.0.1:5000/query"
    headers = {
        "Content-Type": "application/json"
    }
    data = {
        "query": "What is Lumi"
    }
    
    try:
        response = requests.post(url, headers=headers, json=data)
        print("Status Code:", response.status_code)
        print("Response:", json.dumps(response.json(), indent=2))
    except Exception as e:
        print("Error:", str(e))

if __name__ == "__main__":
    test_api()
```

5. Additional requirements (make sure these are installed):

```bash
pip install flask flask-cors asyncpg numpy scikit-learn tensorflow-text requests
```

This implementation:
- Properly handles async/await in Flask
- Maintains CORS support
- Includes error handling
- Returns properly formatted JSON responses
- Logs key information for debugging

Key differences from your original implementation:
1. Added async keyword to the Flask route
2. Properly awaits the main() function
3. Added better error handling and validation
4. Includes proper response formatting

Would you like me to:
1. Add more detailed error handling?
2. Include additional validation?
3. Add logging configuration?
4. Create a more comprehensive test suite?