 I see. If the UI is updating but the response isn't changing, it's likely that the filtering is not being applied correctly or the filtered data isn't being used to render the table. Let's modify the code to ensure the filtering is working properly and the filtered data is being used. Here's an updated version of the Services component:

```jsx
import React, { useState, useEffect } from 'react';
import { FilterMenu, Checkbox, RadioGroup, RadioButton } from '@americanexpress/dls-react';
import './Services.css';

const Services = () => {
  const [services, setServices] = useState([]);
  const [filteredServices, setFilteredServices] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showMenu, setShowMenu] = useState(false);
  const [filters, setFilters] = useState({
    type: [],
    status: ''
  });

  useEffect(() => {
    fetchServices();
  }, []);

  useEffect(() => {
    applyFilters();
  }, [services, filters]);

  const fetchServices = async () => {
    try {
      const response = await fetch('https://lumigcpauto-dev.aexp.com/admin/resources', {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setServices(data);
      setFilteredServices(data);
    } catch (e) {
      console.error('Error fetching services:', e);
      setError('Failed to fetch services. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const applyFilters = () => {
    let result = services;

    if (filters.type.length > 0) {
      result = result.filter(service => filters.type.includes(service.type));
    }

    if (filters.status) {
      result = result.filter(service => service.status === filters.status);
    }

    setFilteredServices(result);
  };

  const handleFilterClick = () => {
    setShowMenu(!showMenu);
  };

  const handleClose = () => {
    setShowMenu(false);
  };

  const handleApply = () => {
    applyFilters();
    setShowMenu(false);
  };

  const handleTypeChange = (event) => {
    const { value, checked } = event.target;
    setFilters(prevFilters => ({
      ...prevFilters,
      type: checked 
        ? [...prevFilters.type, value]
        : prevFilters.type.filter(type => type !== value)
    }));
  };

  const handleStatusChange = (event) => {
    setFilters(prevFilters => ({
      ...prevFilters,
      status: event.target.value
    }));
  };

  return (
    <div className="services-container">
      <h1>All Services</h1>
      <FilterMenu
        showMenu={showMenu}
        showResetButton={false}
        onFilterButtonClick={handleFilterClick}
        onClose={handleClose}
        onApplyButtonClick={handleApply}
        filtersApplied={filters.type.length > 0 || filters.status !== ''}
        filtersLabel="Filter by category"
      >
        <RadioGroup defaultChecked="1">
          <legend theme={{
            padding: '20px 18px',
            lineHeight: '18px',
            fontWeight: '18px important'
          }}>
            STATUS
          </legend>
          <RadioButton 
            id="active-radio" 
            label="Active" 
            value="ACTIVE"
            checked={filters.status === 'ACTIVE'}
            onChange={handleStatusChange}
          />
          <RadioButton 
            id="terminated-radio" 
            label="Terminated" 
            value="TERMINATED"
            checked={filters.status === 'TERMINATED'}
            onChange={handleStatusChange}
          />
        </RadioGroup>
        <h3 className="heading-1 pad-1r pad-t-1r margin-b-0">TYPE</h3>
        <div role="group" className="pad-1" aria-labelledby="animals-label">
          <Checkbox 
            id="multi-filter-check-1" 
            label="Workbench Instance" 
            value="workbench_instance"
            checked={filters.type.includes('workbench_instance')}
            onChange={handleTypeChange}
          />
          <Checkbox 
            id="multi-filter-check-2" 
            label="Data Proc" 
            value="data_proc"
            checked={filters.type.includes('data_proc')}
            onChange={handleTypeChange}
          />
        </div>
      </FilterMenu>

      {loading && <p>Loading services...</p>}
      {error && <p className="error-message">{error}</p>}
      {filteredServices.length > 0 && (
        <table className="services-table">
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Type</th>
              <th>Created By</th>
              <th>Status</th>
              <th>Created At</th>
              <th>Updated At</th>
              <th>Project ID</th>
              <th>Region</th>
              <th>Zone</th>
            </tr>
          </thead>
          <tbody>
            {filteredServices.map((service) => {
              const config = parseConfig(service.config || '');
              return (
                <tr key={service.id}>
                  <td>{service.id || 'N/A'}</td>
                  <td>{service.name || 'N/A'}</td>
                  <td>{service.type || 'N/A'}</td>
                  <td>{service.createdBy || 'N/A'}</td>
                  <td>{service.status || 'N/A'}</td>
                  <td>{service.createdAt ? new Date(service.createdAt).toLocaleString() : 'N/A'}</td>
                  <td>{service.updatedAt ? new Date(service.updatedAt).toLocaleString() : 'N/A'}</td>
                  <td>{config.project_id || 'N/A'}</td>
                  <td>{config.region || 'N/A'}</td>
                  <td>{config.zone || 'N/A'}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      )}
      {/* Keep your existing Pagination component here */}
    </div>
  );
};

export default Services;
```

Key changes:

1. We now have two separate states: `services` (all services) and `filteredServices` (filtered services).
2. The `applyFilters` function is called whenever `services` or `filters` change (using a useEffect).
3. The table now renders `filteredServices` instead of `services`.
4. The `applyFilters` function is more explicit in how it filters the services.

These changes should ensure that the table updates whenever the filters are changed. If you're still not seeing changes, there might be an issue with the data itself. You can add some console.log statements in the `applyFilters` function to see what's happening:

```javascript
const applyFilters = () => {
  console.log('Applying filters:', filters);
  console.log('All services:', services);

  let result = services;

  if (filters.type.length > 0) {
    result = result.filter(service => filters.type.includes(service.type));
    console.log('After type filter:', result);
  }

  if (filters.status) {
    result = result.filter(service => service.status === filters.status);
    console.log('After status filter:', result);
  }

  setFilteredServices(result);
  console.log('Final filtered services:', result);
};
```

This will help you see exactly what's happening during the filtering process. Make sure that the `type` and `status` properties in your service objects match exactly what you're filtering for.