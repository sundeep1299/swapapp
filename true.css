class PriorityQueue:
    def __init__(self, total_gpus):
        self.total_gpus = total_gpus
        self.queue = []
        self.user_priority_count = {}  # Tracks priority usage per user
        self.priority_limit = 3  # 3 priority requests per user per week

    def add_request(self, user_id, gpu_count, is_priority=False):
        # Check priority quota
        if is_priority:
            if self.user_priority_count.get(user_id, 0) >= self.priority_limit:
                is_priority = False  # Downgrade to normal if quota exceeded
            else:
                self.user_priority_count[user_id] = self.user_priority_count.get(user_id, 0) + 1

        # Calculate base score (higher is better)
        score = 1.0
        if is_priority:
            score *= 2.0  # Priority requests get double score
        
        # Smaller requests get bonus
        if gpu_count <= self.total_gpus * 0.3:  # Small request
            score *= 1.3
        
        self.queue.append({
            'user_id': user_id,
            'gpu_count': gpu_count,
            'score': score,
            'timestamp': time.time()
        })

    def allocate_gpus(self):
        if not self.queue:
            return []
        
        # Update scores based on wait time
        current_time = time.time()
        for request in self.queue:
            wait_hours = (current_time - request['timestamp']) / 3600
            request['score'] *= (1 + wait_hours * 0.1)  # 10% boost per hour
        
        # Sort by score
        self.queue.sort(key=lambda x: x['score'], reverse=True)
        
        allocated = []
        available_gpus = self.total_gpus
        
        # Allocate GPUs
        remaining_requests = []
        for request in self.queue:
            if request['gpu_count'] <= available_gpus:
                allocated.append(request)
                available_gpus -= request['gpu_count']
            else:
                remaining_requests.append(request)
        
        self.queue = remaining_requests
        return allocated