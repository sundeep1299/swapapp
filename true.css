Let's try a simpler approach using Quart instead of Flask, since Quart is specifically designed to handle async routes. Here's the corrected `app.py`:

```python
from quart import Quart, request, jsonify
from quart_cors import cors
from request_to_llm import main

app = Quart(__name__)
app = cors(app)

@app.route('/query', methods=['POST'])
async def lumi_orchestrator():
    try:
        data = await request.get_json()
        if "query" not in data:
            return jsonify({"error": "query is required"}), 400
            
        query = data.get('query')
        print(f"Received query: {query}")
        
        result = await main(query)
        print(f"Result: {result}")
        return jsonify(result)
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000, debug=True)
```

First, install Quart:
```bash
pip install quart quart-cors
```

Key changes:
1. Switched from Flask to Quart (which is async-first)
2. Changed the imports accordingly
3. Using Quart's native async support
4. Simplified the server setup

The main differences are:
- Using Quart instead of Flask
- Using `await request.get_json()` instead of `request.get_json()`
- No need for ASGI conversion or hypercorn

This should resolve the coroutine error you're seeing. The error occurred because Flask wasn't properly handling the async response, but Quart is designed specifically for async operations.

Try running it with:
```bash
python app.py
```

Test with curl:
```bash
curl -X POST http://127.0.0.1:5000/query \
-H "Content-Type: application/json" \
-d '{"query": "What is Lumi"}'
```

Let me know if you still encounter any errors!