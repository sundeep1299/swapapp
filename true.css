 Certainly! I'll modify the existing code to include two additional buttons for "Managed Notebooks" and "Workbench Instances", each with its own GET call. Here's how we can update the `ProjectSelection` component:

```jsx
import React, { useState } from 'react';
import { useAuthBlueSso } from 'use-authblue-sso';
import { ButtonPrimary, IconSetting } from '@americanexpress/dls-react';
import './ProjectSelection.css';
import gcpLogo from './gcp-logo.png';

const ProjectSelection = () => {
  const [resources, setResources] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const { user } = useAuthBlueSso();

  const fetchData = async (endpoint) => {
    setLoading(true);
    setError(null);
    try {
      const userId = user?.attributes?.adsid || 'vsing379';
      const response = await fetch(`https://lumiqcpauto-dev.aexp.com/terraform/automate/${endpoint}/${userId}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setResources(data);
    } catch (e) {
      console.error(`Error fetching ${endpoint}:`, e);
      setError(`Failed to fetch ${endpoint}. Please try again.`);
    } finally {
      setLoading(false);
    }
  };

  const fetchDataProc = () => fetchData('data_proc');
  const fetchManagedNotebooks = () => fetchData('managed_notebooks');
  const fetchWorkbenchInstances = () => fetchData('workbench_instance');

  // ... (parseConfig function remains the same)

  return (
    <div className="project-selection">
      <h2>GCP Resources</h2>
      <div className="button-group">
        <ButtonPrimary 
          icon={<IconSetting title="Data Proc" />} 
          onClick={fetchDataProc} 
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Data Proc'}
        </ButtonPrimary>
        <ButtonPrimary 
          icon={<IconSetting title="Managed Notebooks" />} 
          onClick={fetchManagedNotebooks} 
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Managed Notebooks'}
        </ButtonPrimary>
        <ButtonPrimary 
          icon={<IconSetting title="Workbench Instances" />} 
          onClick={fetchWorkbenchInstances} 
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Workbench Instances'}
        </ButtonPrimary>
      </div>
      
      {error && <p className="error-message">{error}</p>}
      
      {resources.length > 0 && (
        <div className="table-container">
          <div className="table-header">
            <img src={gcpLogo} alt="GCP Logo" className="gcp-logo" />
            <h3 className="table-title">GCP Resource List</h3>
          </div>
          <table className="resources-table">
            {/* ... (table header and body remain the same) ... */}
          </table>
        </div>
      )}
    </div>
  );
};

export default ProjectSelection;
```

Now, let's update the CSS to style the new button group:

```css
.button-group {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.button-group button {
  flex: 1;
}

/* ... (rest of the CSS remains the same) ... */
```

These changes include:

1. A new `fetchData` function that takes an endpoint parameter, allowing us to reuse the same fetch logic for different resources.
2. Three separate functions (`fetchDataProc`, `fetchManagedNotebooks`, `fetchWorkbenchInstances`) that call `fetchData` with the appropriate endpoint.
3. Three buttons in the UI, each calling its respective fetch function.
4. Updated CSS to style the new button group.

This setup allows users to fetch different types of GCP resources (Data Proc, Managed Notebooks, and Workbench Instances) using separate buttons. The table will update to show the fetched resources based on which button was clicked.

Remember that you might need to adjust the table columns and parsing logic if the data structure for Managed Notebooks and Workbench Instances differs from the Data Proc resources. You may want to create separate parsing and rendering logic for each resource type if they have significantly different structures.